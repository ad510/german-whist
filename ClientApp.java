// ClientApp.java
// Copyright (c) 2012 Andrew Downing
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
@mainpage German Whist card game

@section cardimg Compilation/Usage Instructions

See compile.txt for instructions to compile and run the code.

@section networknote Note About Networking Errors

If the server and the client are run on the same computer, the networking usually works fine. However, if they are run on different computers, then messages may fairly frequently (but at unpredictable times) not be received correctly, causing dropped messages or disconnects. Prof. Crowley said I won't be penalized for this, so I didn't take the time to implement packet numbering and re-requesting.

@section overview Overview

This Java program implements the card game German Whist as described at https://en.wikipedia.org/wiki/German_Whist , using a client-server model and including an AI client. See compile.txt for compiling and usage instructions.

@section serverreqs Server Requirements

- Save player data when it changes and load it at startup.
- Send data to the clients when they request it or when otherwise appropriate.
- Allow clients to start and stop a game, request player stats, sign in, create a player, and play the game (1 client per player).

@section clientreqs Client Requirements
- Implement German Whist as described at https://en.wikipedia.org/wiki/German_Whist .
- The client represents a single player, and must interface with a server to play a game and do other activities.
- Use menus for starting and stopping a game, exiting, creating players, and listing all players.
- Have a panel each for creating players, displaying player stats, signing in to a player, and playing the game (1 client per player).
- The program must use a GUI for all input and output. (Note that I occasionally outputted unrecoverable errors in the terminal.)
- Include a separate AI client program that uses an AI to choose cards to play.

@section classes Classes

See the "Classes" tab at the top of the page.

@section globals Global Data/Functions

Java requires that all variables and functions are in a class, so there are no global variables or functions. (Am I misinterpreting this section?)

@section arch High-level Architecture

Instead of using a separate thread for each client connection, I decided to instead poll for new messages with a short timeout in case there are no new messages, influencing my architecture. In the loop() method, the ServerApp class polls for new messages every 200 milliseconds and responds to them if it receives new ones. The ClientApp class sends messages throughout the code, but only receives messages in the method pollServer() which is called every 200 milliseconds using a timer. They network using the PlayerSocket class, which is a wrapper around Java's networking API that represents a single player. Classes that can be used as messages end with Msg, and since I would have written them as structures in C++, I made all variables in these classes publicly accessible. To synchronize games between clients, I decided that since the client needed to know many of the game rules anyway (such as whether a given card is a valid one to play and whether it's a valid time to play it), I might as well implement all of the game rules on the client and only use the server to broadcast messages that each client sends. (I only needed one message type containing a single int saying which card was played. I think this decision reduced the total amount and complexity of the code overall.) To make sure clients start out with the same game, they all use the same random number seed randomly generated by one of the clients to generate the game. The AI is implemented in a subclass of GamePanel called GameAIPanel. Since the AI client benefits from much of the GUI code anyway to sign in and pick a game to join, the main() method that starts the AI client simply creates a ClientApp frame with a different constructor argument. The sole effect on the ClientApp frame is to change the window title and to create a GameAIPanel instead of a GamePanel in the constructor. (Since I used inheritance, the ClientApp code other than the constructor can treat the GameAIPanel in exactly the same way.)

@section ui User Interface

There are 2 menus: Player and Game. The Player menu lets the user sign in, create a new player (which must be done the first time you play), change the password, delete the account, view the leaderboard, and exit. The Game menu lets the user join a game or view the status of the upcoming game, continue the game if the user has switched to a different panel, or abruptly stop the game for all users. The sign in/new player panel requests the server address, player name, and password, with a submit button at the bottom and a label to display messages or errors. Changing the password simply involves entering a new password and pressing the Change Password button, and deleting the account requires password confirmation. In terms of the GUI, the game lobby is the biggest difference from homework 2. If the user hasn't joined a game, the user will be presented with a list of games to join and an additional button to host a new game. If the user has joined a game, the players in the upcoming game will be displayed, with buttons to leave or start the game. In-game, the talon deck is at the upper right, the player's hand is spread out along the bottom, and a status display is at top center. When it is the user's turn, the user plays a card by clicking it, moving the card to the upper left. When all players have played a card, the winner of the trick is determined and each player receives 1 card from the talon. When the game has ended, the winner is displayed with instructions to start a new game. (See https://en.wikipedia.org/wiki/German_Whist for more detailed game rules.)

@section testing Test Cases

In addition to those from homework 2, cases to test for include networking errors (which are mostly handled in the PlayerSocket class), making sure the server can handle multiple simultaneous synchronized game sessions since I decided to implement that, making sure the server saves the players file at the right times, ignoring messages sent at the wrong time, and handling off-nominal disconnections. Nominal test cases include adding and deleting (valid) players, viewing player stats, and starting a game. The PlayerSocket class handles the off-nominal case of a StreamCorruptedException being thrown by disconnecting from the network. Changing this to something more intelligent might be a good idea if I were to improve upon the game in the future, considering the frequency at which this error is thrown when the clients and server are on different computers. (If the server and the client are run on the same computer, the networking usually works fine.)
*/

import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.net.*;

/** client application window containing menus and top-level panels/panes */
public class ClientApp extends JFrame implements ActionListener, MenuListener {
  private static final Color BackColor = new Color(255, 192, 128); /**< background color of panels */
  private static final Insets StdInsets = new Insets(10, 10, 10, 10); /**< standard padding around laid out components */
  private static final String SettingsPath = "save/players_old.dat"; /**< file path of player data file */

  // menus
  private JMenuBar menuBar; /**< menu bar displayed at top of window */
  private JMenu menuPlayer; /**< menu for player-related menu items */
  private JMenuItem menuSignIn; /**< menu to sign in to existing player */
  private JMenuItem menuNewPlayer; /**< menu to create and sign in to new player */
  private JMenuItem menuChangePassword; /**< menu to show change password panel */
  private JMenuItem menuDeleteAccount; /**< menu to delete player account (requires confirmation) */
  private JMenuItem menuLeaderboard; /**< menu to display leaderboard panel */
  private JMenuItem menuExit; /**< menu to exit program */
  private JMenu menuGame; /**< menu for game-related menu items */
  private JMenuItem menuLobby; /**< menu to show available games or status of upcoming game session */
  private JMenuItem menuContinueGame; /**< menu to continue game that has been started */
  private JMenuItem menuStopGame; /**< menu to end game in its current state */

  /** layout of the window, containing the different application panels */
  private CardLayout layout;
  /** name of the current panel or pane being displayed */
  private String currentPanel;

  // panels
  private SignInPanel panelSignIn; /**< panel to sign in to (and possibly create new account on) server */
  private TextInputPanel panelChangePassword; /**< panel to change password */
  private TextInputPanel panelDeleteAccount; /**< panel to confirm account deletion */
  private LobbyPanel panelLobby; /**< panel to wait for players to join game */
  private SelectInputPane paneJoinGame; /**< scroll pane to select game to join */
  private PlayerStatsPane panePlayerStats; /**< scroll pane to display player statistics */
  private GamePanel panelGame; /**< panel to play German Whist */

  /** connection to server */
  private PlayerSocket socket;
  /** ArrayList describing available game sessions (sent from server) */
  private ArrayList<GameSession> games;
  /** description of game session this client is currently in */
  private GameSession currentGame;

  /** constructor for game window */
  public ClientApp(boolean isAIClient) {
    int i, j;
    // set up window
    if (isAIClient) {
      setTitle("German Whist (AI)");
    }
    else {
      setTitle("German Whist");
    }
    setSize(640, 500);
    setLocationRelativeTo(null); // center window on screen
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // exit program when window is closed
    addWindowListener(new AppCloseListener());
    // instantiate menus
    menuBar = new JMenuBar();
    menuPlayer = new JMenu("Player");
    menuSignIn = new JMenuItem("Sign In");
    menuNewPlayer = new JMenuItem("New Player");
    menuChangePassword = new JMenuItem("Change Password");
    menuDeleteAccount = new JMenuItem("Delete Account");
    menuLeaderboard = new JMenuItem("Leaderboard");
    menuExit = new JMenuItem("Exit");
    menuGame = new JMenu("Game");
    menuLobby = new JMenuItem("Game Lobby");
    menuContinueGame = new JMenuItem("Continue Game");
    menuStopGame = new JMenuItem("Stop Game");
    // add menus
    menuPlayer.add(menuSignIn);
    menuPlayer.add(menuNewPlayer);
    menuPlayer.addSeparator();
    menuPlayer.add(menuChangePassword);
    menuPlayer.add(menuDeleteAccount);
    menuPlayer.addSeparator();
    menuPlayer.add(menuLeaderboard);
    menuPlayer.addSeparator();
    menuPlayer.add(menuExit);
    menuGame.add(menuLobby);
    menuGame.addSeparator();
    menuGame.add(menuContinueGame);
    menuGame.add(menuStopGame);
    menuBar.add(menuPlayer);
    menuBar.add(menuGame);
    setJMenuBar(menuBar);
    // register menu item listeners
    for (i = 0; i < menuBar.getMenuCount(); i++) {
      menuBar.getMenu(i).addMenuListener(this); // to update whether items are enabled when menu is clicked
      for (j = 0; j < menuBar.getMenu(i).getItemCount(); j++) {
        if (menuBar.getMenu(i).getItem(j) instanceof JMenuItem) { // skip separators
          menuBar.getMenu(i).getItem(j).addActionListener(this);
        }
      }
    }
    // set up card layout
    layout = new CardLayout();
    setLayout(layout);
    // instantiate panels and panes
    panelSignIn = new SignInPanel(this, BackColor, StdInsets);
    panelChangePassword = new TextInputPanel("Enter new password", "Change Password", true, this, BackColor, StdInsets);
    panelDeleteAccount = new TextInputPanel("Enter password to confirm account deletion", "Delete Account", true, this, BackColor, StdInsets);
    panelLobby = new LobbyPanel(this, BackColor, StdInsets);
    paneJoinGame = new SelectInputPane(this, BackColor, StdInsets);
    paneJoinGame.update("Waiting for available games list...", new ArrayList<String>()); // fall back gracefully if pane isn't ready yet
    panePlayerStats = new PlayerStatsPane(BackColor, StdInsets);
    if (isAIClient) {
      panelGame = new GameAIPanel(BackColor);
    }
    else {
      panelGame = new GamePanel(BackColor);
    }
    // add panels
    add(panelSignIn, "sign in");
    add(panelChangePassword, "change password");
    add(panelDeleteAccount, "delete account");
    add(panelLobby, "lobby");
    add(paneJoinGame, "join game");
    add(panePlayerStats, "player stats");
    add(panelGame, "game");
    // start networking timer
    new javax.swing.Timer(ServerApp.UpdateInterval, this).start();
    // show sign in panel
    setVisible(true); // display window
    panelSignIn.initSignIn();
    showPanel("sign in");
  }

  public static void main(String[] args) {
    ClientApp app = new ClientApp(false);
  }

  /** handle menu or button click */
  public void actionPerformed(ActionEvent ae) {
    Object src = ae.getSource();
    int i;
    // player menu
    if (src == menuSignIn) { // show panel to sign in to server
      panelSignIn.initSignIn();
      showPanel("sign in");
    }
    else if (src == menuNewPlayer) { // show panel to create new player then sign in to that player
      panelSignIn.initNewPlayer();
      showPanel("sign in");
    }
    else if (src == menuChangePassword) { // show panel to change password
      showPanel("change password");
    }
    else if (src == menuDeleteAccount) { // confirm account deletion
      showPanel("delete account");
    }
    else if (src == menuLeaderboard) { // show leaderboard panel
      showPanel("player stats");
    }
    else if (src == menuExit) { // exit program
      // call window closing events of window listeners
      WindowListener[] windowListeners = getWindowListeners();
      for (i = 0; i < windowListeners.length; i++) {
        windowListeners[i].windowClosing(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
      }
      // exit program
      System.exit(0);
    }
    // game menu
    else if (src == menuLobby) { // show available games or status of upcoming game session
      if (!signedIn()) {
        panelSignIn.initSignIn();
        panelSignIn.setActionMsg("Sign in to enter game lobby");
        showPanel("sign in");
      }
      else if (currentGame != null) {
        showPanel("lobby");
      }
      else if (games != null) {
        showPanel("join game");
      }
    }
    else if (src == menuContinueGame) { // continue game that has been started
      if (!panelGame.getGameOver()) {
        showPanel("game");
      }
    }
    else if (src == menuStopGame) { // end game in its current state
      panelGame.stopGame();
      if (currentPanel.equals("game")) {
        showPanel("join game"); // game panel should not be displayed when a game is not being played
      }
    }
    // sign in panel
    else if (src == panelSignIn) {
      try {
        if (socket != null) {
          // disconnect from existing connection
          socket.close();
          socket = null;
          Thread.sleep(ServerApp.UpdateInterval); // wait for server to receive message
        }
        socket = new PlayerSocket(new Socket(panelSignIn.getServerAddress(), ServerApp.Port));
        Thread.sleep(ServerApp.UpdateInterval); // wait for server to receive message
        socket.write(panelSignIn.getPacket());
      }
      catch (Exception ex) {
        socket = null;
        panelSignIn.setActionError("Could not connect to server; check that it was entered correctly");
      }
    }
    // change password panel
    else if (src == panelChangePassword) {
      String password = ae.getActionCommand();
      if (password.isEmpty()) {
        panelChangePassword.setActionError("Please enter a new password");
      }
      else {
        panelChangePassword.setActionMsg("Changing password...");
        socket.write(new StringMsg(StringMsg.MsgType.ChangePassword, password));
      }
    }
    // delete account panel
    else if (src == panelDeleteAccount) {
      String password = ae.getActionCommand();
      if (password.isEmpty()) {
        panelChangePassword.setActionError("Please enter your password");
      }
      else {
        panelChangePassword.setActionMsg("Deleting account...");
        socket.write(new StringMsg(StringMsg.MsgType.DeleteAccount, password));
      }
    }
    // lobby panel
    else if (src == panelLobby) {
      if (ae.getActionCommand().equals("leave")) {
        socket.write(new GameSessionMsg(new GameSession())); // new GameSession() defaults to playing = false, which is what we want
      }
      else if (ae.getActionCommand().equals("start")) {
        socket.write(new StartGameMsg());
      }
    }
    // join game pane
    else if (src == paneJoinGame) {
      String session = ae.getActionCommand();
      GameSession msg = new GameSession();
      msg.playing = true;
      if (session.equals("Host New Game")) {
        socket.write(new GameSessionMsg(msg));
      }
      else {
        msg.players = games.get(Integer.parseInt(session.substring(0, session.indexOf('.'))) - 1).players;
        socket.write(new GameSessionMsg(msg));
      }
    }
    // networking timer
    else if (src instanceof javax.swing.Timer) {
      pollServer();
    }
    // unhandled
    else {
      System.out.println("TODO: handle actionPerformed of " + src.toString());
    }
  }

  /** update whether certain menu items are enabled when menu is clicked */
  public void menuSelected(MenuEvent e) {
    boolean enable;
    if (e.getSource() == menuPlayer) {
      enable = signedIn();
      menuChangePassword.setEnabled(enable);
      menuDeleteAccount.setEnabled(enable);
      menuLeaderboard.setEnabled(enable);
    }
    else if (e.getSource() == menuGame) {
      menuLobby.setEnabled(panelGame.getGameOver());
      menuContinueGame.setEnabled(signedIn() && !panelGame.getGameOver());
      menuStopGame.setEnabled(signedIn() && !panelGame.getGameOver());
    }
  }

  public void menuDeselected(MenuEvent e) {
  }

  public void menuCanceled(MenuEvent e) {
  }

  /** show panel (or pane) of specified name */
  private void showPanel(String panelName) {
    int i, j;
    if (panelName.equals("sign in")) {
      // panel can be shown as is (caller should have initialized it manually)
    }
    else if (panelName.equals("change password")) {
      panelChangePassword.reset();
    }
    else if (panelName.equals("delete account")) {
      panelDeleteAccount.reset();
    }
    else if (panelName.equals("lobby")) {
      // panel automatically synced with server
    }
    else if (panelName.equals("join game")) {
      // pane automatically synced with server
    }
    else if (panelName.equals("player stats")) {
      if (signedIn()) {
        socket.write(new PlayerStatsMsg()); // request updated player stats from server
      }
    }
    else if (panelName.equals("game")) {
      if (panelGame.getGameOver()) {
        throw new IllegalStateException("A game has not been started");
      }
    }
    else {
      throw new IllegalArgumentException("There is no panel or pane called \"" + panelName + "\"");
    }
    layout.show(this.getContentPane(), panelName);
    currentPanel = panelName;
  }

  /** check for and handle messages from server */
  private void pollServer() {
    Object msgObj = null;
    int i, j;
    if (socket == null) {
      return;
    }
    do {
      msgObj = socket.read();
      if (msgObj != null) {
        // received a message, handle it
        //System.out.println("Received message from server: " + msgObj);
        if (msgObj instanceof CloseConnectionMsg) {
          // close connection with server
          signOut("Unexpectedly disconnected from server");
          msgObj = null;
        }
        else if (msgObj instanceof PlayerStatsMsg) {
          // update leaderboard
          panePlayerStats.update(((PlayerStatsMsg)msgObj).players);
        }
        else if (msgObj instanceof GameSessionListMsg) {
          // update available game sessions
          ArrayList<String> choices = new ArrayList<String>();
          games = ((GameSessionListMsg)msgObj).toGameSessionList();
          currentGame = null;
          choices.add("Host New Game");
          for (i = 0; i < games.size(); i++) {
            StringBuilder choice = new StringBuilder();
            choice.append(i + 1);
            choice.append(". ");
            for (j = 0; j < games.get(i).players.size(); j++) {
              choice.append(games.get(i).players.get(j));
              if (j < games.get(i).players.size() - 1) {
                choice.append(", ");
              }
            }
            choices.add(choice.toString());
          }
          paneJoinGame.update("Select game session to join", choices);
          if (currentPanel.equals("lobby") || (currentPanel.equals("game") && !panelGame.getGameOver())) {
            showPanel("join game");
          }
          if (!panelGame.getGameOver()) {
            panelGame.stopGame(); // receiving this message means we are no longer in game session, so stop game now
          }
        }
        else if (msgObj instanceof GameSessionMsg) {
          // update current game session
          currentGame = ((GameSessionMsg)msgObj).toGameSession();
          games = null;
          panelLobby.update(currentGame.players);
          if (currentPanel.equals("join game")) {
            showPanel("lobby");
          }
        }
        else if (msgObj instanceof StartGameMsg) {
          // start game
          StartGameMsg msg = (StartGameMsg)msgObj;
          panelGame.newGame(msg.players.toGameSession().players, msg.seed, socket);
          showPanel("game");
        }
        else if (msgObj instanceof GamePlayMsg) {
          // another player played a card
          if (!panelGame.playTrick(((GamePlayMsg)msgObj).card)) {
            System.out.println("Warning: received message to play an invalid card");
          }
        }
        else if (msgObj instanceof StringMsg) {
          StringMsg msg = (StringMsg)msgObj;
          if (msg.type == StringMsg.MsgType.SignInSuccess) {
            // successfully signed in
            games = null;
            currentGame = null;
            socket.setPlayerName(msg.message);
            showPanel("join game");
          }
          else if (msg.type == StringMsg.MsgType.SignInError) {
            // unsuccessfully signed in, display error message
            socket.setPlayerName(null);
            panelSignIn.setActionError(msg.message);
          }
          else if (msg.type == StringMsg.MsgType.ChangePassword) {
            if (msg.message.isEmpty()) {
              // password successfully changed
              panelChangePassword.setActionMsg("Password successfully changed");
            }
            else {
              // password not changed successfully
              panelChangePassword.setActionError(msg.message);
            }
          }
          else if (msg.type == StringMsg.MsgType.DeleteAccount) {
            if (msg.message.isEmpty()) {
              // account successfully deleted
              signOut("Player account successfully deleted");
              msgObj = null;
            }
            else {
              // account not deleted successfully
              panelDeleteAccount.setActionError(msg.message);
            }
          }
          else {
            System.out.println("Warning: received StringMsg of unknown type " + msg.type.toString());
          }
        }
        else {
          System.out.println("Warning: received unknown message " + msgObj);
        }
      }
    } while (msgObj != null);
  }

  /** close connection with server */
  private void signOut(String message) {
    socket.close();
    socket = null;
    panelSignIn.initSignIn();
    panelSignIn.setActionMsg(message);
    showPanel("sign in");
  }

  /** returns whether currently signed in to server */
  private boolean signedIn() {
    return (socket != null && socket.getPlayerName() != null);
  }

  /** class to handle window close event */
  private class AppCloseListener extends WindowAdapter {
    /** handle window close event */
    public void windowClosing(WindowEvent e) {
      if (socket != null) {
        socket.close();
        socket = null;
      }
    }
  }
}
